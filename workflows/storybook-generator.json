{
  "name": "Storybook Generator - n8n Cloud Compatible",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "generate-storybook",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "9e2945c6-bb3b-4cb5-a2de-a858af6d7b90",
      "name": "1. Webhook Input",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        0,
        300
      ],
      "webhookId": "storybook-generator-webhook"
    },
    {
      "parameters": {
        "jsCode": "// Direct webhook payload processing - simplified for reliability\nconst input = $input.first().json;\nconst body = input.body || input;\nconst storyText = body.storyText || '';\nconst settings = body.settings || {};\nconst storyId = body.storyId || crypto.randomUUID();\n\n// Hero image support - base64 encoded custom protagonist photo\nconst heroImage = settings.heroImage || body.heroImage || null;\n\nreturn [{\n  json: {\n    storyText,\n    settings,\n    storyId,\n    targetAge: settings.targetAge || 6,\n    desiredPageCount: settings.desiredPageCount || 10,\n    intensity: settings.harshness || 5,\n    aestheticStyle: settings.aestheticStyle || 'watercolor children\\'s book illustration',\n    freeformNotes: settings.freeformNotes || '',\n    saveToSupabase: true,\n    heroImage: heroImage\n  }\n}];"
      },
      "id": "0a155b51-edb0-4ce1-a581-143b8be1d537",
      "name": "Extract & Validate Inputs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        220,
        300
      ],
      "notes": "SIMPLIFIED: Uses webhook payload directly - no external fetch calls"
    },
    {
      "parameters": {
        "jsCode": "// Create story record in Supabase IMMEDIATELY so frontend can start polling\nconst data = $input.first().json;\n\n// Hardcoded Supabase service key (same as other nodes)\nconst supabaseServiceKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpudnFxbnJ3dXpqdGRncWxrZ3ZmIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2NDAyNTgyMSwiZXhwIjoyMDc5NjAxODIxfQ.IWZV4x0vHZxBZAhOFKkwbB9LgZf8vk9e15MxBHhYxYU';\n\ntry {\n  const response = await fetch('https://znvqqnrwuzjtdgqlkgvf.supabase.co/rest/v1/stories', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'apikey': supabaseServiceKey,\n      'Authorization': `Bearer ${supabaseServiceKey}`,\n      'Prefer': 'resolution=merge-duplicates'\n    },\n    body: JSON.stringify({\n      id: data.storyId,\n      source_text: (data.storyText || '').substring(0, 10000),\n      settings: data.settings,\n      title: 'Generating...',\n      status: 'generating',\n      current_step: 'analyzing'\n    })\n  });\n  \n  if (!response.ok) {\n    console.error('Initial Supabase save failed:', response.status, await response.text());\n  } else {\n    console.log('Story record created:', data.storyId);\n  }\n} catch (e) {\n  console.error('Initial Supabase save error:', e.message);\n}\n\n// Return original data to continue pipeline\nreturn [{ json: data }];"
      },
      "id": "create-story-record",
      "name": "Create Story Record",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        320,
        300
      ],
      "notes": "CRITICAL: Creates story record IMMEDIATELY so frontend polling works even if workflow fails later"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": {{ JSON.stringify(\"You are an expert literary analyst. Analyze this story and provide a deep understanding of its narrative structure.\\n\\nSTORY TEXT:\\n\" + $json.storyText.substring(0, 8000) + \"\\n\\nTARGET AUDIENCE: \" + $json.targetAge + \"-year-old reader\\n\\nANALYZE AND RETURN JSON:\\n{\\n  \\\"title\\\": \\\"Story title or best guess\\\",\\n  \\\"theme\\\": \\\"Core theme in 1-2 sentences\\\",\\n  \\\"emotionalArc\\\": \\\"Description of the emotional journey\\\",\\n  \\\"protagonistJourney\\\": \\\"What the main character learns or achieves\\\",\\n  \\\"keyMoments\\\": [\\n    \\\"List of 8-12 most important/visual moments in the story\\\"\\n  ],\\n  \\\"tone\\\": \\\"Overall tone (e.g., whimsical, adventurous, heartwarming)\\\",\\n  \\\"setting\\\": \\\"Primary setting(s) description\\\",\\n  \\\"keyEnvironments\\\": [\\n    \\\"List of 3-5 distinct locations/environments that appear multiple times\\\"\\n  ],\\n  \\\"ageAppropriatenessNotes\\\": \\\"Any content considerations for the target age\\\"\\n}\\n\\nReturn ONLY valid JSON.\") }}\n    }]\n  }],\n  \"generationConfig\": {\n    \"temperature\": 1.0,\n    \"topP\": 0.95,\n    \"maxOutputTokens\": 4096\n  }\n}",
        "options": {
          "timeout": 60000,
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "id": "31388475-faf8-4b69-aa57-382265f6c6a0",
      "name": "2. Story Analyzer",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        440,
        300
      ],
      "credentials": {
        "httpQueryAuth": {
          "id": "",
          "name": "Gemini API Key"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "ADJUSTABLE: Edit this prompt to change how the AI interprets story structure. Uses gemini-3-pro-preview for text analysis."
    },
    {
      "parameters": {
        "jsCode": "// Unified JSON parser - reusable pattern for all AI responses\nfunction parseAIResponse(responseText, fallback = {}) {\n  try {\n    // Handle Gemini API response structure\n    let text = responseText;\n    if (typeof responseText === 'object') {\n      text = responseText?.candidates?.[0]?.content?.parts?.[0]?.text || \n             responseText?.text || \n             JSON.stringify(responseText);\n    }\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      return JSON.parse(jsonMatch[0]);\n    }\n  } catch (e) {\n    console.error('JSON parse error:', e.message);\n  }\n  return { ...fallback, parseError: true, rawResponse: String(responseText).substring(0, 500) };\n}\n\nconst responseBody = $input.first().json.body || $input.first().json;\nconst analysis = parseAIResponse(responseBody, {\n  title: 'Untitled Story',\n  theme: 'Unknown',\n  keyMoments: [],\n  keyEnvironments: [],\n  tone: 'neutral'\n});\n\n// Carry forward all previous data\nconst prevData = $('Extract & Validate Inputs').first().json;\n\nreturn [{\n  json: {\n    ...prevData,\n    analysis\n  }\n}];"
      },
      "id": "16da2be7-2e48-4795-af87-cab57408e3ed",
      "name": "Parse Story Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        660,
        300
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": {{ JSON.stringify(\"You are selecting scenes for a \" + $json.desiredPageCount + \"-page children's picture book.\\n\\nSTORY ANALYSIS:\\nTitle: \" + ($json.analysis.title || 'Untitled') + \"\\nTheme: \" + ($json.analysis.theme || 'Unknown') + \"\\nEmotional Arc: \" + ($json.analysis.emotionalArc || 'Not specified') + \"\\nKey Moments: \" + JSON.stringify($json.analysis.keyMoments || []) + \"\\n\\nTARGET: \" + $json.targetAge + \"-year-old reader\\nPAGE COUNT: Exactly \" + $json.desiredPageCount + \" pages\\nINTENSITY: \" + $json.intensity + \"/10\\n\\nSCENE SELECTION PRINCIPLES:\\n1. NARRATIVE ESSENTIALS - Include pivotal plot moments\\n2. EMOTIONAL PEAKS - Joy, discovery, challenge, resolution\\n3. VISUAL IMPACT - Strong visual potential and variety\\n4. CHARACTER DEVELOPMENT - Show growth and relationships\\n5. PACING - Balance action with reflection\\n6. ICONIC MOMENTS - For known stories, include expected scenes\\n7. AGE APPROPRIATENESS - Resonate with target age\\n8. VISUAL VARIETY - Mix wide shots, close-ups, different compositions\\n\\nHANDLING STORY LENGTH:\\n- SHORT STORY: Break moments into multiple pages, expand emotional beats\\n- LONG STORY: Combine related moments, focus on high-impact scenes\\n\\nReturn EXACTLY \" + $json.desiredPageCount + \" scenes as JSON:\\n{\\n  \\\"scenes\\\": [\\n    {\\n      \\\"pageNumber\\\": 1,\\n      \\\"moment\\\": \\\"The key moment this page captures\\\",\\n      \\\"emotionalBeat\\\": \\\"What the reader should feel\\\",\\n      \\\"visualPotential\\\": \\\"Why this moment is visually interesting\\\",\\n      \\\"cameraAngle\\\": \\\"wide shot | medium shot | close-up\\\",\\n      \\\"environment\\\": \\\"Which location/setting this scene takes place in\\\"\\n    }\\n  ],\\n  \\\"storyArcSummary\\\": [\\n    \\\"First major beat\\\",\\n    \\\"Second major beat\\\",\\n    \\\"Third major beat\\\",\\n    \\\"Resolution\\\"\\n  ]\\n}\\n\\nReturn ONLY valid JSON with exactly \" + $json.desiredPageCount + \" scenes.\") }}\n    }]\n  }],\n  \"generationConfig\": {\n    \"temperature\": 1.0,\n    \"topP\": 0.95,\n    \"maxOutputTokens\": 8192\n  }\n}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "f2a87cb3-b4dc-4ff8-936d-60b92fcec9d9",
      "name": "3. Scene Selector",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        880,
        300
      ],
      "credentials": {
        "httpQueryAuth": {
          "id": "",
          "name": "Gemini API Key"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "ADJUSTABLE: Edit the 8 principles to change scene selection criteria."
    },
    {
      "parameters": {
        "jsCode": "function parseAIResponse(responseText, fallback = {}) {\n  try {\n    let text = responseText;\n    if (typeof responseText === 'object') {\n      text = responseText?.candidates?.[0]?.content?.parts?.[0]?.text || \n             responseText?.text || \n             JSON.stringify(responseText);\n    }\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) return JSON.parse(jsonMatch[0]);\n  } catch (e) { console.error('Parse error:', e.message); }\n  return { ...fallback, parseError: true };\n}\n\nconst responseBody = $input.first().json.body || $input.first().json;\nconst sceneData = parseAIResponse(responseBody, { scenes: [], storyArcSummary: [] });\n\nconst prevData = $('Parse Story Analysis').first().json;\n\nreturn [{\n  json: {\n    ...prevData,\n    scenes: sceneData.scenes || [],\n    storyArcSummary: sceneData.storyArcSummary || []\n  }\n}];"
      },
      "id": "bdea8504-0a1a-4ba5-a9af-3db9769c188f",
      "name": "Parse Scenes",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1100,
        300
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": {{ JSON.stringify(\"You are writing captions for a \" + $json.desiredPageCount + \"-page children's picture book.\\n\\nTARGET AGE: \" + $json.targetAge + \" years old\\nSTORY THEME: \" + ($json.analysis.theme || 'Unknown') + \"\\nTONE: \" + ($json.analysis.tone || 'child-friendly') + \"\\n\\nAGE-APPROPRIATE LANGUAGE GUIDELINES:\\n\" + ($json.targetAge <= 5 ? '- Very simple language, basic concepts, short sentences (5-8 words)' : ($json.targetAge <= 8 ? '- Simple but engaging sentences, adventure vocabulary, 8-12 words per sentence' : ($json.targetAge <= 12 ? '- More complex sentences, richer vocabulary, can handle nuance, 10-15 words' : '- Sophisticated language, nuanced themes, literary quality, varied sentence length'))) + \"\\n\\nSCENES TO CAPTION:\\n\" + JSON.stringify($json.scenes, null, 2) + \"\\n\\nFor each scene, write a caption that:\\n1. Is age-appropriate for a \" + $json.targetAge + \"-year-old\\n2. Captures the emotional moment\\n3. Flows naturally when read aloud\\n4. Avoids spoiling future events\\n5. Works standalone but connects to the larger story\\n\\nReturn JSON:\\n{\\n  \\\"captions\\\": [\\n    {\\n      \\\"pageNumber\\\": 1,\\n      \\\"caption\\\": \\\"The actual caption text to display\\\"\\n    }\\n  ]\\n}\\n\\nReturn ONLY valid JSON.\") }}\n    }]\n  }],\n  \"generationConfig\": {\n    \"temperature\": 1.0,\n    \"topP\": 0.95,\n    \"maxOutputTokens\": 4096\n  }\n}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "3771dba0-9e91-47fd-92b1-23ce7380b73a",
      "name": "4. Caption Writer",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1320,
        300
      ],
      "credentials": {
        "httpQueryAuth": {
          "id": "",
          "name": "Gemini API Key"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "ADJUSTABLE: Edit the age-appropriate language guidelines to change vocabulary complexity."
    },
    {
      "parameters": {
        "jsCode": "function parseAIResponse(responseText, fallback = {}) {\n  try {\n    let text = responseText;\n    if (typeof responseText === 'object') {\n      text = responseText?.candidates?.[0]?.content?.parts?.[0]?.text || \n             responseText?.text || \n             JSON.stringify(responseText);\n    }\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) return JSON.parse(jsonMatch[0]);\n  } catch (e) { console.error('Parse error:', e.message); }\n  return { ...fallback, parseError: true };\n}\n\nconst responseBody = $input.first().json.body || $input.first().json;\nconst captionData = parseAIResponse(responseBody, { captions: [] });\n\nconst prevData = $('Parse Scenes').first().json;\n\n// Merge captions into scenes to create pages\nconst pages = prevData.scenes.map((scene, idx) => {\n  const caption = captionData.captions?.find(c => c.pageNumber === scene.pageNumber);\n  return {\n    ...scene,\n    caption: caption?.caption || `Page ${scene.pageNumber}`\n  };\n});\n\nreturn [{\n  json: {\n    ...prevData,\n    pages\n  }\n}];"
      },
      "id": "0c482521-7f6a-4c21-a487-59bacd8497b5",
      "name": "Parse Captions & Build Pages",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1540,
        300
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": {{ JSON.stringify(\"You are identifying characters for a children's picture book to ensure visual consistency.\\n\\nSTORY TEXT:\\n\" + $json.storyText.substring(0, 6000) + \"\\n\\nPAGES/SCENES:\\n\" + JSON.stringify($json.pages, null, 2) + \"\\n\\n\" + ($json.heroImage ? \"IMPORTANT: A custom photo reference has been provided for the protagonist. The first character you identify should be marked as isHero: true and their description should note that a photo reference exists.\" : \"\") + \"\\n\\nExtract ALL characters that appear in the story. For each character, provide:\\n1. PRECISE visual description - physical features, clothing, colors, props\\n2. Their role in the story\\n3. Approximate age or size relative to others\\n4. Any distinctive visual markers that must remain consistent\\n\\nReturn JSON:\\n{\\n  \\\"characters\\\": [\\n    {\\n      \\\"name\\\": \\\"Character Name\\\",\\n      \\\"description\\\": \\\"PRECISE visual description: [hair color/style], [eye color], [skin tone], [body type], [clothing with specific colors], [distinctive props/accessories], [approximate age/size]\\\",\\n      \\\"role\\\": \\\"main\\\" | \\\"supporting\\\" | \\\"background\\\",\\n      \\\"isHero\\\": true | false,\\n      \\\"keyFeatures\\\": [\\\"brown curly hair\\\", \\\"red coat\\\", \\\"round glasses\\\"],\\n      \\\"appearsOnPages\\\": [1, 3, 5, 7]\\n    }\\n  ]\\n}\\n\\nIMPORTANT:\\n- First character should be the protagonist with isHero: true\\n- Next 1-2 characters should be 'main' role\\n- Next 2-3 characters should be 'supporting' role\\n- Rest are 'background'\\n- Be VERY specific about colors and visual details\\n- These descriptions will be used to maintain consistency across all images\\n\\nReturn ONLY valid JSON.\") }}\n    }]\n  }],\n  \"generationConfig\": {\n    \"temperature\": 1.0,\n    \"topP\": 0.95,\n    \"maxOutputTokens\": 4096\n  }\n}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "a57eda6f-b92f-45f7-b26a-baa981445a98",
      "name": "5. Character Extractor",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1760,
        300
      ],
      "credentials": {
        "httpQueryAuth": {
          "id": "",
          "name": "Gemini API Key"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "Edit to change character description detail level."
    },
    {
      "parameters": {
        "jsCode": "// Parse characters AND create Style Bible in one node\n// Also extracts environments for reference generation\n\nfunction parseAIResponse(responseText, fallback = {}) {\n  try {\n    let text = responseText;\n    if (typeof responseText === 'object') {\n      text = responseText?.candidates?.[0]?.content?.parts?.[0]?.text || \n             responseText?.text || \n             JSON.stringify(responseText);\n    }\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) return JSON.parse(jsonMatch[0]);\n  } catch (e) { console.error('Parse error:', e.message); }\n  return { ...fallback, parseError: true };\n}\n\nconst responseBody = $input.first().json.body || $input.first().json;\nconst charData = parseAIResponse(responseBody, { characters: [] });\n\nconst prevData = $('Parse Captions & Build Pages').first().json;\nconst style = (prevData.aestheticStyle || '').toLowerCase();\n\n// Mark hero character and attach hero image if provided\nconst characters = (charData.characters || []).map((char, idx) => {\n  if (char.isHero && prevData.heroImage) {\n    return { ...char, heroImageProvided: true };\n  }\n  return char;\n});\n\n// Extract unique environments from scenes and analysis\nconst sceneEnvironments = [...new Set(prevData.pages?.map(p => p.environment).filter(Boolean) || [])];\nconst analysisEnvironments = prevData.analysis?.keyEnvironments || [];\nconst allEnvironments = [...new Set([...sceneEnvironments, ...analysisEnvironments])].slice(0, 5);\n\n// Style Bible creation\nfunction extractArtStyle(s) {\n  if (s.includes('watercolor')) return 'watercolor illustration';\n  if (s.includes('cartoon')) return 'cartoon style';\n  if (s.includes('digital')) return 'digital art';\n  if (s.includes('sketch')) return 'sketch illustration';\n  if (s.includes('pixar') || s.includes('3d')) return 'Pixar-style 3D render';\n  if (s.includes('paper') || s.includes('cutout')) return 'paper cutout style';\n  return 'children\\'s book illustration style';\n}\n\nfunction extractColorPalette(s) {\n  if (s.includes('warm')) return 'warm, inviting colors';\n  if (s.includes('pastel')) return 'soft pastel tones';\n  if (s.includes('bright')) return 'bright, cheerful colors';\n  if (s.includes('muted')) return 'muted, gentle tones';\n  return 'child-friendly color palette';\n}\n\nfunction extractLighting(s) {\n  if (s.includes('soft')) return 'soft, diffused lighting';\n  if (s.includes('golden')) return 'warm golden hour lighting';\n  if (s.includes('bright')) return 'bright, even lighting';\n  return 'gentle, natural lighting';\n}\n\nfunction getVisualDensity(age) {\n  if (age <= 5) return 'Simple, bold elements, large shapes, minimal background, high contrast';\n  if (age <= 8) return 'Moderate detail, engaging backgrounds, balanced complexity';\n  if (age <= 12) return 'Rich, intricate details, layered compositions, complex backgrounds';\n  return 'Advanced visual complexity, mature artistic techniques';\n}\n\nconst styleBible = {\n  artStyle: extractArtStyle(style),\n  colorPalette: extractColorPalette(style),\n  lighting: extractLighting(style),\n  composition: 'child-friendly perspective, clear focal points, intricate backgrounds',\n  visualDensity: getVisualDensity(prevData.targetAge),\n  doNots: [\n    'dark shadows',\n    'scary elements', \n    'violent imagery',\n    'any text, captions, or typography in the image',\n    'speech bubbles',\n    'signs with readable text'\n  ]\n};\n\nreturn [{\n  json: {\n    ...prevData,\n    characters,\n    environments: allEnvironments,\n    styleBible\n  }\n}];"
      },
      "id": "0f5ff7c3-5591-438a-9b27-c0c804d7c497",
      "name": "6. Parse Characters & Create Style Bible",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1980,
        300
      ],
      "notes": "ADJUSTABLE: Edit style functions. Also extracts environments for reference generation."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "should-save",
              "leftValue": "={{ $json.saveToSupabase }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "3a798919-fe91-47aa-8a88-106677767564",
      "name": "Save to Supabase?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2200,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Update story in Supabase with analysis results and advance step\nconst data = $input.first().json;\n\ntry {\n  const response = await fetch('https://znvqqnrwuzjtdgqlkgvf.supabase.co/rest/v1/stories', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'apikey': $credentials.httpHeaderAuth.value,\n      'Authorization': `Bearer ${$credentials.httpHeaderAuth.value}`,\n      'Prefer': 'resolution=merge-duplicates'\n    },\n    body: JSON.stringify({\n      id: data.storyId,\n      source_text: (data.storyText || '').substring(0, 10000),\n      settings: data.settings,\n      theme: data.analysis?.theme || '',\n      title: data.analysis?.title || 'Untitled',\n      status: 'generating',\n      current_step: 'portraits'\n    })\n  });\n  \n  if (!response.ok) {\n    console.error('Supabase save failed:', response.status);\n  }\n} catch (e) {\n  console.error('Supabase save error:', e.message);\n}\n\n// CRITICAL: Return original data, not API response\nreturn [{ json: data }];"
      },
      "id": "aa491d2f-748d-4527-bae5-4579c32924ca",
      "name": "7. Save to Supabase",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2420,
        200
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "anXAvdazFeZf1z1L",
          "name": "Supabase Service Key"
        }
      },
      "notes": "Saves story metadata to Supabase AND passes original data through (Code node instead of HTTP Request)"
    },
    {
      "parameters": {
        "jsCode": "// Simply pass through data from whichever branch executed\nconst data = $input.first().json;\nreturn [{ json: data }];"
      },
      "id": "99af69df-fcd7-427b-8c3e-a1293aa01b79",
      "name": "Continue Pipeline",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2640,
        300
      ],
      "notes": "Merge point after optional Supabase save - just passes data through"
    },
    {
      "parameters": {
        "jsCode": "// Prepare characters for portrait generation loop\nconst data = $input.first().json;\nconst characters = (data.characters || []).filter(c => c.role === 'main' || c.role === 'supporting' || c.isHero);\n\n// Only generate portraits for main, supporting, and hero characters\nif (characters.length === 0) {\n  return [{\n    json: {\n      ...data,\n      characterReferences: [],\n      skipPortraitGeneration: true\n    }\n  }];\n}\n\nreturn characters.map((char, idx) => ({\n  json: {\n    characterIndex: idx,\n    character: char,\n    storyId: data.storyId,\n    aestheticStyle: data.aestheticStyle,\n    targetAge: data.targetAge,\n    styleBible: data.styleBible,\n    totalCharacters: characters.length,\n    heroImage: char.isHero ? data.heroImage : null,\n    allData: data\n  }\n}));"
      },
      "id": "4cb02d88-2222-4e3f-993e-49a292a87096",
      "name": "Prep Character Portraits",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2860,
        300
      ],
      "notes": "Processes main, supporting, and hero characters. Passes hero image for protagonist."
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "45926580-bff2-4707-a182-1c9b6f2d0c5b",
      "name": "8. Character Portrait Loop",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        3080,
        300
      ],
      "notes": "ADJUSTABLE: Change batchSize to process more characters in parallel (may hit rate limits)."
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Create a character reference sheet for children's book illustration:\\n\\nCHARACTER: {{ $json.character.name }}\\nROLE: {{ $json.character.role }}{{ $json.character.isHero ? ' (PROTAGONIST)' : '' }}\\nDESCRIPTION: {{ $json.character.description }}\\nKEY FEATURES: {{ $json.character.keyFeatures ? $json.character.keyFeatures.join(', ') : 'As described' }}\\n\\nSTYLE: {{ $json.aestheticStyle }}\\nART DIRECTION: {{ $json.styleBible.artStyle }}\\n\\nCREATE:\\n- Front-facing portrait showing full character design\\n- Clear, consistent lighting\\n- Neutral background (white or light parchment)\\n- Professional children's book illustration quality\\n- NO TEXT OR LABELS in the image\\n\\nUNIFIED STYLE (Critical):\\n- All characters must share the EXACT same rendering style\\n- Match the art style: {{ $json.styleBible.artStyle }}\\n- Color palette: {{ $json.styleBible.colorPalette }}\\n- Lighting: {{ $json.styleBible.lighting }}\\n\\nThis image should be safe for children ages 3-12.\\n\\nGenerate a single character reference image.\"\n    }]\n  }],\n  \"generationConfig\": {\n    \"responseModalities\": [\"TEXT\", \"IMAGE\"]\n  }\n}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "36fa9d1f-4342-4dca-8377-5eed562cebd8",
      "name": "Generate Portrait",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3300,
        300
      ],
      "credentials": {
        "httpQueryAuth": {
          "id": "",
          "name": "Gemini API Key"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "Uses gemini-3-pro-image-preview for character portraits. Supports hero photo reference for protagonist."
    },
    {
      "parameters": {
        "jsCode": "// MEMORY FIX: Parse, Save to Supabase, and STRIP base64 before returning to loop\n// This prevents base64 accumulation in SplitInBatches node\nconst data = $input.first().json;\nconst responseBody = data.body || data;\nlet referenceImage = null;\n\n// Extract image from Gemini response\ntry {\n  const candidates = responseBody?.candidates || [];\n  for (const candidate of candidates) {\n    const parts = candidate?.content?.parts || [];\n    for (const part of parts) {\n      if (part.inlineData) {\n        referenceImage = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;\n        break;\n      }\n    }\n    if (referenceImage) break;\n  }\n} catch (e) {\n  console.error('Error extracting image:', e.message);\n}\n\nconst storyId = data.storyId;\nconst characterName = data.character?.name || '';\nconst characterDescription = data.character?.description || '';\nconst characterRole = data.character?.role || 'supporting';\nconst isHero = data.character?.isHero || false;\nconst keyFeatures = data.character?.keyFeatures || [];\n\n// Save to Supabase immediately (saveToSupabase is always true)\nlet savedOk = false;\nif (referenceImage) {\n  try {\n    const supabaseUrl = 'https://znvqqnrwuzjtdgqlkgvf.supabase.co/rest/v1/characters';\n    const response = await fetch(supabaseUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'apikey': $credentials.httpHeaderAuth.value,\n        'Authorization': `Bearer ${$credentials.httpHeaderAuth.value}`,\n        'Prefer': 'return=minimal'\n      },\n      body: JSON.stringify({\n        story_id: storyId,\n        name: characterName,\n        description: characterDescription,\n        role: characterRole,\n        is_hero: isHero,\n        reference_image: referenceImage,\n        status: 'completed'\n      })\n    });\n    savedOk = response.ok;\n    if (!response.ok) {\n      console.error('Supabase save failed:', response.status);\n    }\n  } catch (e) {\n    console.error('Supabase save error:', e.message);\n  }\n}\n\n// CRITICAL: Return ONLY metadata - NO base64!\n// This prevents memory accumulation in the loop\nreturn [{\n  json: {\n    // Minimal metadata for aggregation\n    characterName,\n    characterRole,\n    characterDescription,\n    isHero,\n    keyFeatures,\n    savedToSupabase: savedOk,\n    hasImage: !!referenceImage,\n    // Keep storyId for reference\n    storyId\n  }\n}];"
      },
      "id": "c530a604-f6f4-4087-9d63-f416dc27f236",
      "name": "Parse + Save + Strip Character",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3380,
        300
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "anXAvdazFeZf1z1L",
          "name": "Supabase Service Key"
        }
      },
      "notes": "MEMORY FIX: Saves to Supabase immediately and returns ONLY metadata (no base64) to prevent memory accumulation in loop"
    },
    {
      "parameters": {
        "unit": "seconds",
        "amount": 3
      },
      "id": "a1afd76e-9877-45fc-a4a3-a3e098c1b1d5",
      "name": "Character Rate Limit",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        3800,
        300
      ],
      "notes": "ADJUSTABLE: Increase wait time if hitting Gemini rate limits."
    },
    {
      "parameters": {
        "jsCode": "// Aggregate character metadata - images already saved to Supabase\nconst items = $input.all();\nconst firstItem = items[0]?.json || {};\n\nlet allData;\nif (firstItem.skipPortraitGeneration) {\n  allData = firstItem;\n} else {\n  allData = $('Continue Pipeline').first().json;\n}\n\n// Items now contain clean metadata (no base64) from Parse + Save + Strip nodes\nconst characterRefs = items.map(item => {\n  if (item.json.skipPortraitGeneration) return null;\n  \n  return {\n    name: item.json.characterName,\n    role: item.json.characterRole,\n    isHero: item.json.isHero || false,\n    description: item.json.characterDescription,\n    keyFeatures: item.json.keyFeatures,\n    referenceImage: item.json.savedToSupabase ? '[SAVED_TO_SUPABASE]' : null,\n    savedToSupabase: item.json.savedToSupabase || false\n  };\n}).filter(c => c && c.name);\n\n// Explicit field selection - no storyText (large) after this point\nreturn [{\n  json: {\n    storyId: allData.storyId,\n    storyText: allData.storyText,\n    settings: allData.settings,\n    targetAge: allData.targetAge,\n    desiredPageCount: allData.desiredPageCount,\n    intensity: allData.intensity,\n    aestheticStyle: allData.aestheticStyle,\n    saveToSupabase: allData.saveToSupabase,\n    heroImage: allData.heroImage,\n    analysis: allData.analysis,\n    pages: allData.pages,\n    characters: allData.characters,\n    environments: allData.environments,\n    styleBible: allData.styleBible,\n    characterReferences: characterRefs\n  }\n}];"
      },
      "id": "1ebcd374-38c7-47c4-851c-2d3d59db9eee",
      "name": "Aggregate Character Portraits",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3940,
        300
      ],
      "notes": "Aggregates character metadata - base64 images already saved to Supabase"
    },
    {
      "parameters": {
        "jsCode": "// Prepare environments for reference generation loop\nconst data = $input.first().json;\nconst environments = data.environments || [];\n\n// Skip if no environments identified\nif (environments.length === 0) {\n  return [{\n    json: {\n      ...data,\n      environmentReferences: [],\n      skipEnvironmentGeneration: true\n    }\n  }];\n}\n\nreturn environments.map((env, idx) => ({\n  json: {\n    environmentIndex: idx,\n    environmentName: env,\n    storyId: data.storyId,\n    aestheticStyle: data.aestheticStyle,\n    targetAge: data.targetAge,\n    styleBible: data.styleBible,\n    analysis: data.analysis,\n    totalEnvironments: environments.length,\n    allData: data\n  }\n}));"
      },
      "id": "59af68ff-617f-49ae-a1d0-eb4233d113cf",
      "name": "Prep Environment References",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3960,
        300
      ],
      "notes": "Prepares up to 5 key environments for reference image generation"
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "262e1622-a691-4503-bc55-ad5f2950f83b",
      "name": "8b. Environment Reference Loop",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        4180,
        300
      ],
      "notes": "Generates reference images for recurring locations/environments"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Create an environment/location reference for children's book illustration:\\n\\nLOCATION: {{ $json.environmentName }}\\nSTORY SETTING: {{ $json.analysis?.setting || 'As described in the story' }}\\nSTORY TONE: {{ $json.analysis?.tone || 'child-friendly' }}\\n\\nSTYLE: {{ $json.aestheticStyle }}\\nART DIRECTION: {{ $json.styleBible.artStyle }}\\n\\nCREATE:\\n- Wide establishing shot of this location\\n- Empty scene (no characters) to use as background reference\\n- Clear lighting that matches the story's mood\\n- Rich environmental details appropriate for the story\\n- Professional children's book illustration quality\\n- NO TEXT OR LABELS in the image\\n\\nUNIFIED STYLE (Critical):\\n- Must match character portrait style exactly\\n- Art style: {{ $json.styleBible.artStyle }}\\n- Color palette: {{ $json.styleBible.colorPalette }}\\n- Lighting: {{ $json.styleBible.lighting }}\\n- Visual density: {{ $json.styleBible.visualDensity }}\\n\\nThis location will appear multiple times in the book, so establish a clear visual identity.\\nThis image should be safe for children ages 3-12.\\n\\nGenerate an environment reference image.\"\n    }]\n  }],\n  \"generationConfig\": {\n    \"responseModalities\": [\"TEXT\", \"IMAGE\"]\n  }\n}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "44b18e54-366c-4c7e-b56f-1894eb4b8c72",
      "name": "Generate Environment Reference",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        4400,
        300
      ],
      "credentials": {
        "httpQueryAuth": {
          "id": "",
          "name": "Gemini API Key"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "Uses gemini-3-pro-image-preview for location references."
    },
    {
      "parameters": {
        "jsCode": "// MEMORY FIX: Parse, Save to Supabase, and STRIP base64 before returning to loop\n// This prevents base64 accumulation in SplitInBatches node\nconst data = $input.first().json;\nconst responseBody = data.body || data;\nlet referenceImage = null;\n\n// Extract image from Gemini response\ntry {\n  const candidates = responseBody?.candidates || [];\n  for (const candidate of candidates) {\n    const parts = candidate?.content?.parts || [];\n    for (const part of parts) {\n      if (part.inlineData) {\n        referenceImage = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;\n        break;\n      }\n    }\n    if (referenceImage) break;\n  }\n} catch (e) {\n  console.error('Error extracting image:', e.message);\n}\n\nconst storyId = data.storyId;\nconst environmentName = data.environmentName || '';\n\n// Save to Supabase immediately\nlet savedOk = false;\nif (referenceImage) {\n  try {\n    const supabaseUrl = 'https://znvqqnrwuzjtdgqlkgvf.supabase.co/rest/v1/environments';\n    const response = await fetch(supabaseUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'apikey': $credentials.httpHeaderAuth.value,\n        'Authorization': `Bearer ${$credentials.httpHeaderAuth.value}`,\n        'Prefer': 'return=minimal'\n      },\n      body: JSON.stringify({\n        story_id: storyId,\n        name: environmentName,\n        reference_image: referenceImage,\n        status: 'completed'\n      })\n    });\n    savedOk = response.ok;\n    if (!response.ok) {\n      console.error('Supabase save failed:', response.status);\n    }\n  } catch (e) {\n    console.error('Supabase save error:', e.message);\n  }\n}\n\n// CRITICAL: Return ONLY metadata - NO base64!\nreturn [{\n  json: {\n    environmentName,\n    savedToSupabase: savedOk,\n    hasImage: !!referenceImage,\n    storyId\n  }\n}];"
      },
      "id": "9c0c647e-31d2-4553-8129-1ec92e72fc49",
      "name": "Parse + Save + Strip Environment",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4520,
        300
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "anXAvdazFeZf1z1L",
          "name": "Supabase Service Key"
        }
      },
      "notes": "MEMORY FIX: Saves to Supabase immediately and returns ONLY metadata (no base64) to prevent memory accumulation in loop"
    },
    {
      "parameters": {
        "unit": "seconds",
        "amount": 3
      },
      "id": "0804b008-96cd-4448-8c2f-37505a1715e2",
      "name": "Environment Rate Limit",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        4720,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Aggregate environment metadata - images already saved to Supabase\nconst items = $input.all();\nconst firstItem = items[0]?.json || {};\n\nlet allData;\nif (firstItem.skipEnvironmentGeneration) {\n  allData = firstItem;\n} else {\n  allData = $('Aggregate Character Portraits').first().json;\n}\n\n// Items now contain clean metadata (no base64) from Parse + Save + Strip nodes\nconst environmentRefs = items.map(item => {\n  if (item.json.skipEnvironmentGeneration) return null;\n  \n  return {\n    name: item.json.environmentName,\n    referenceImage: item.json.savedToSupabase ? '[SAVED_TO_SUPABASE]' : null,\n    savedToSupabase: item.json.savedToSupabase || false\n  };\n}).filter(e => e && e.name);\n\n// Explicit field selection\nreturn [{\n  json: {\n    storyId: allData.storyId,\n    storyText: allData.storyText,\n    settings: allData.settings,\n    targetAge: allData.targetAge,\n    desiredPageCount: allData.desiredPageCount,\n    intensity: allData.intensity,\n    aestheticStyle: allData.aestheticStyle,\n    saveToSupabase: allData.saveToSupabase,\n    heroImage: allData.heroImage,\n    analysis: allData.analysis,\n    pages: allData.pages,\n    characters: allData.characters,\n    environments: allData.environments,\n    styleBible: allData.styleBible,\n    characterReferences: allData.characterReferences,\n    environmentReferences: environmentRefs\n  }\n}];"
      },
      "id": "9fab3f3f-26d6-4fa2-8c91-a87fa8a7c92b",
      "name": "Aggregate Environment References",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4940,
        300
      ],
      "notes": "Aggregates environment metadata - base64 images already saved to Supabase"
    },
    {
      "parameters": {
        "jsCode": "// Prepare pages for illustration loop\nconst data = $input.first().json;\nconst pages = data.pages || [];\n\nif (pages.length === 0) {\n  return [{ json: { ...data, generatedPages: [], error: 'No pages to generate' } }];\n}\n\nreturn pages.map((page, idx) => ({\n  json: {\n    pageIndex: idx,\n    page: page,\n    storyId: data.storyId,\n    aestheticStyle: data.aestheticStyle,\n    targetAge: data.targetAge,\n    styleBible: data.styleBible,\n    characterReferences: data.characterReferences,\n    environmentReferences: data.environmentReferences,\n    totalPages: pages.length,\n    intensity: data.intensity,\n    allData: data\n  }\n}));"
      },
      "id": "2596cf4f-45b4-4433-a847-55d7d8650edd",
      "name": "Prep Page Illustrations",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5060,
        300
      ]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "6862034f-8250-4a1b-8e26-27c48364ac9a",
      "name": "9. Page Illustrator Loop",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        5280,
        300
      ],
      "notes": "ADJUSTABLE: Change batchSize to process pages in parallel (costs more, faster)."
    },
    {
      "parameters": {
        "jsCode": "// Build comprehensive page illustration prompt\nconst data = $input.first().json;\nconst page = data.page;\nconst pageIndex = data.pageIndex ?? 0;\n\n// Defensive check - ensure page exists\nif (!page) {\n  throw new Error(`Page data is undefined for pageIndex ${pageIndex}. Data keys: ${Object.keys(data).join(', ')}`);\n}\n\n// Camera angle - use scene's angle or rotate through defaults\nconst defaultAngle = pageIndex % 3 === 0 ? 'wide shot' : \n                     pageIndex % 2 === 0 ? 'medium shot' : 'close-up';\nconst cameraAngle = page.cameraAngle || defaultAngle;\n\nconst cameraDescriptions = {\n  'wide shot': 'Wide establishing shot showing full scene and environment',\n  'medium shot': 'Medium shot framing characters from waist up',\n  'close-up': 'Close-up focusing on facial expressions and emotional details'\n};\n\n// Build character reference section\nconst charRefs = (data.characterReferences || [])\n  .filter(c => c.referenceImage)\n  .map(c => `- ${c.name}${c.isHero ? ' (HERO)' : ''}: MATCH REFERENCE - ${c.keyFeatures?.join(', ') || c.description?.substring(0, 100)}`)\n  .join('\\n');\n\n// Build environment reference section\nconst envRef = (data.environmentReferences || [])\n  .find(e => page.environment && e.name.toLowerCase().includes(page.environment.toLowerCase()));\nconst envRefText = envRef ? `\\nENVIRONMENT REFERENCE: Match the visual style of \"${envRef.name}\" reference image.` : '';\n\nconst prompt = `SCENE: ${page.moment || page.caption}\n\nCAPTION: \"${page.caption}\"\n\nCOMPOSITION:\n- Camera: ${cameraDescriptions[cameraAngle] || cameraDescriptions['medium shot']}\n- Layout: FULL-PAGE illustration filling entire canvas\n- Use rule of thirds, create depth with foreground/midground/background\n\nINTENSITY: ${data.intensity}/10\n${data.intensity >= 7 ? '- DRAMATIC and emotionally intense' : data.intensity >= 4 ? '- Moderately engaging' : '- Gentle and calm'}\n\nCHARACTER CONSISTENCY (CRITICAL):\n${charRefs || 'No specific references'}\n\nLOCATION: ${page.environment || 'As described'}${envRefText}\n\nSTYLE:\n- Art: ${data.styleBible?.artStyle || data.aestheticStyle}\n- Colors: ${data.styleBible?.colorPalette || 'child-friendly'}\n- Lighting: ${data.styleBible?.lighting || 'natural'}\n- Density: ${data.styleBible?.visualDensity || 'age-appropriate'}\n\nTECHNICAL:\n- Full-page, no text in image\n- High resolution, publication-ready\n- Safe for ages 3-12\n\nGenerate illustration for page ${pageIndex + 1}.`;\n\nreturn [{\n  json: {\n    ...data,\n    illustrationPrompt: prompt\n  }\n}];"
      },
      "id": "3d75e9c1-b688-4bf5-bf75-f93c2290e842",
      "name": "Build Page Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5500,
        300
      ],
      "notes": "ADJUSTABLE: Edit camera angle logic, intensity mappings, or composition rules. Now includes environment references."
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": {{ JSON.stringify($json.illustrationPrompt) }}\n    }]\n  }],\n  \"generationConfig\": {\n    \"responseModalities\": [\"TEXT\", \"IMAGE\"]\n  }\n}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "623e8289-cb03-45d2-a451-ee260361e28c",
      "name": "Generate Page Image",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        5720,
        300
      ],
      "credentials": {
        "httpQueryAuth": {
          "id": "",
          "name": "Gemini API Key"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "Uses gemini-3-pro-image-preview for page illustrations."
    },
    {
      "parameters": {
        "jsCode": "// MEMORY FIX: Parse, Save to Supabase, and STRIP base64 before returning to loop\n// This prevents base64 accumulation in SplitInBatches node\nconst data = $input.first().json;\nconst responseBody = data.body || data;\nlet imageData = null;\n\n// Extract image from Gemini response\ntry {\n  const candidates = responseBody?.candidates || [];\n  for (const candidate of candidates) {\n    const parts = candidate?.content?.parts || [];\n    for (const part of parts) {\n      if (part.inlineData) {\n        imageData = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;\n        break;\n      }\n    }\n    if (imageData) break;\n  }\n} catch (e) {\n  console.error('Error extracting image:', e.message);\n}\n\nconst storyId = data.storyId;\nconst pageNumber = (data.pageIndex || 0) + 1;\nconst caption = data.page?.caption || '';\nconst moment = data.page?.moment || '';\nconst environment = data.page?.environment || '';\nconst cameraAngle = data.page?.cameraAngle || '';\nconst prompt = data.illustrationPrompt || '';\n\n// Save to Supabase immediately\nlet savedOk = false;\nif (imageData) {\n  try {\n    const supabaseUrl = 'https://znvqqnrwuzjtdgqlkgvf.supabase.co/rest/v1/pages';\n    const response = await fetch(supabaseUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'apikey': $credentials.httpHeaderAuth.value,\n        'Authorization': `Bearer ${$credentials.httpHeaderAuth.value}`,\n        'Prefer': 'return=minimal'\n      },\n      body: JSON.stringify({\n        story_id: storyId,\n        page_number: pageNumber,\n        caption: caption,\n        prompt: prompt,\n        image_url: imageData,\n        status: 'completed'\n      })\n    });\n    savedOk = response.ok;\n    if (!response.ok) {\n      console.error('Supabase save failed:', response.status);\n    }\n  } catch (e) {\n    console.error('Supabase save error:', e.message);\n  }\n}\n\n// CRITICAL: Return ONLY metadata - NO base64!\nreturn [{\n  json: {\n    pageNumber,\n    caption,\n    moment,\n    environment,\n    cameraAngle,\n    savedToSupabase: savedOk,\n    hasImage: !!imageData,\n    storyId\n  }\n}];"
      },
      "id": "15d53acd-a9c9-42c5-a5f9-a9b5e066c98f",
      "name": "Parse + Save + Strip Page",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5820,
        300
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "anXAvdazFeZf1z1L",
          "name": "Supabase Service Key"
        }
      },
      "notes": "MEMORY FIX: Saves to Supabase immediately and returns ONLY metadata (no base64) to prevent memory accumulation in loop"
    },
    {
      "parameters": {
        "unit": "seconds",
        "amount": 4
      },
      "id": "e76f1edd-7a4d-46a4-83f5-f62b5c2c915c",
      "name": "Page Rate Limit",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        6240,
        300
      ],
      "notes": "ADJUSTABLE: Increase if hitting Gemini rate limits on image generation."
    },
    {
      "parameters": {
        "jsCode": "// Aggregate page metadata - images already saved to Supabase\nconst items = $input.all();\n\nconst allData = $('Prep Page Illustrations').first()?.json?.allData || $('Aggregate Environment References').first().json;\n\n// Items now contain clean metadata (no base64) from Parse + Save + Strip nodes\nconst generatedPages = items.map((item) => {\n  return {\n    pageNumber: item.json.pageNumber,\n    caption: item.json.caption,\n    moment: item.json.moment,\n    environment: item.json.environment,\n    cameraAngle: item.json.cameraAngle,\n    imageData: item.json.savedToSupabase ? '[SAVED_TO_SUPABASE]' : null,\n    savedToSupabase: item.json.savedToSupabase || false\n  };\n});\n\n// No storyText forward - keeping it slim\nreturn [{\n  json: {\n    storyId: allData.storyId,\n    targetAge: allData.targetAge,\n    intensity: allData.intensity,\n    aestheticStyle: allData.aestheticStyle,\n    saveToSupabase: allData.saveToSupabase,\n    analysis: allData.analysis,\n    styleBible: allData.styleBible,\n    characterReferences: allData.characterReferences,\n    environmentReferences: allData.environmentReferences,\n    storyArcSummary: allData.storyArcSummary,\n    heroImage: allData.heroImage,\n    generatedPages: generatedPages\n  }\n}];"
      },
      "id": "9495dd20-7419-4694-bad2-ee8f73b4a569",
      "name": "Aggregate Pages",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6260,
        300
      ],
      "notes": "Aggregates page metadata - base64 images already saved to Supabase"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": {{ JSON.stringify(\"You are reviewing a \" + ($json.generatedPages ? $json.generatedPages.length : 0) + \"-page picture book for visual consistency.\\n\\nCHARACTER REFERENCES:\\n\" + ($json.characterReferences ? $json.characterReferences.map((c, i) => (i+1) + '. ' + c.name + (c.isHero ? ' (HERO)' : '') + ' (' + c.role + '): ' + (c.keyFeatures ? c.keyFeatures.join(', ') : (c.description || 'No description'))).join('\\n') : 'No references') + \"\\n\\nENVIRONMENT REFERENCES:\\n\" + ($json.environmentReferences ? $json.environmentReferences.map((e, i) => (i+1) + '. ' + e.name).join('\\n') : 'No environment references') + \"\\n\\nBASELINE RULE: PAGE 1 IS THE VISUAL BASELINE. All pages must match Page 1's character and environment depictions.\\n\\nCHECK FOR:\\n1. PROTAGONIST CONSISTENCY - Hair, features must NEVER change\\n2. CHARACTER APPEARANCE - Same look across all appearances\\n3. ENVIRONMENT CONSISTENCY - Same locations should look similar\\n4. TIMELINE LOGIC - State changes should persist\\n5. STYLE DRIFT - Art style should be consistent\\n6. OBJECT CONTINUITY - Recurring items look the same\\n\\nPAGES:\\n\" + ($json.generatedPages ? $json.generatedPages.map(p => 'Page ' + p.pageNumber + ' [' + (p.environment || 'unspecified') + ']: ' + (p.caption || 'No caption')).join('\\n') : 'No pages') + \"\\n\\nReturn JSON:\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"pageNumber\\\": 7,\\n      \\\"type\\\": \\\"character_appearance\\\" | \\\"environment_consistency\\\" | \\\"timeline_logic\\\" | \\\"style_drift\\\",\\n      \\\"description\\\": \\\"Brief description\\\",\\n      \\\"characterInvolved\\\": \\\"Name\\\",\\n      \\\"fixPrompt\\\": \\\"Specific fix instruction\\\"\\n    }\\n  ],\\n  \\\"pagesNeedingRegeneration\\\": [7],\\n  \\\"overallConsistency\\\": \\\"good\\\" | \\\"needs_fixes\\\" | \\\"major_issues\\\"\\n}\\n\\nIf consistent: { \\\"issues\\\": [], \\\"pagesNeedingRegeneration\\\": [], \\\"overallConsistency\\\": \\\"good\\\" }\") }}\n    }]\n  }],\n  \"generationConfig\": {\n    \"temperature\": 1.0,\n    \"topP\": 0.95,\n    \"maxOutputTokens\": 4096\n  }\n}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "38827b5e-bf70-4758-bccb-29a9647e88c5",
      "name": "10. Consistency Reviewer",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        6380,
        300
      ],
      "credentials": {
        "httpQueryAuth": {
          "id": "",
          "name": "Gemini API Key"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "Analyzes page descriptions for consistency issues. Edit to change consistency thresholds."
    },
    {
      "parameters": {
        "jsCode": "function parseAIResponse(responseText, fallback = {}) {\n  try {\n    let text = responseText;\n    if (typeof responseText === 'object') {\n      text = responseText?.candidates?.[0]?.content?.parts?.[0]?.text || \n             responseText?.text || \n             JSON.stringify(responseText);\n    }\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) return JSON.parse(jsonMatch[0]);\n  } catch (e) { console.error('Parse error:', e.message); }\n  return fallback;\n}\n\nconst responseBody = $input.first().json.body || $input.first().json;\nconst reviewData = parseAIResponse(responseBody, { \n  issues: [], \n  pagesNeedingRegeneration: [], \n  overallConsistency: 'good' \n});\n\nconst prevData = $('Aggregate Pages').first().json;\n\nreturn [{\n  json: {\n    ...prevData,\n    consistencyReview: reviewData,\n    needsFixing: (reviewData.pagesNeedingRegeneration || []).length > 0\n  }\n}];"
      },
      "id": "685d826e-bca6-4116-ac16-954a683e4a80",
      "name": "Parse Consistency Review",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6600,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "needs-fixing",
              "leftValue": "={{ $json.needsFixing }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "77d03ce4-e255-4d2d-92dc-e27d7291f72f",
      "name": "Needs Fixing?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        6820,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare pages needing fixes\nconst data = $input.first().json;\nconst pagesToFix = data.consistencyReview?.pagesNeedingRegeneration || [];\nconst issues = data.consistencyReview?.issues || [];\n\nif (pagesToFix.length === 0) {\n  return [{ json: data }];\n}\n\nreturn pagesToFix.slice(0, 3).map(pageNum => {\n  const issue = issues.find(i => i.pageNumber === pageNum);\n  const page = data.generatedPages?.find(p => p.pageNumber === pageNum);\n  \n  return {\n    json: {\n      pageNumber: pageNum,\n      page: page,\n      fixPrompt: issue?.fixPrompt || 'Ensure visual consistency with character and environment references',\n      issue: issue,\n      storyId: data.storyId,\n      aestheticStyle: data.aestheticStyle,\n      styleBible: data.styleBible,\n      characterReferences: data.characterReferences,\n      environmentReferences: data.environmentReferences,\n      allData: data\n    }\n  };\n});"
      },
      "id": "bf3e8124-789d-4ee5-b6d8-6145005002fd",
      "name": "Prep Fix Loop",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7040,
        200
      ],
      "notes": "Limits fixes to max 3 pages per run to prevent infinite loops"
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "fb6f6700-9ea7-48fe-bd49-8034c91ea69a",
      "name": "11. Consistency Fixer Loop",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        7260,
        200
      ],
      "notes": "Only runs if consistency issues found."
    },
    {
      "parameters": {
        "jsCode": "// Build fix prompt with specific instructions\nconst data = $input.first().json;\n\nconst charRefs = (data.characterReferences || [])\n  .filter(c => c.referenceImage)\n  .map(c => `- ${c.name}${c.isHero ? ' (HERO - CRITICAL)' : ''}: MATCH EXACTLY - ${c.keyFeatures?.join(', ') || 'as referenced'}`)\n  .join('\\n');\n\n// Find matching environment reference\nconst envRef = (data.environmentReferences || [])\n  .find(e => data.page?.environment && e.name.toLowerCase().includes(data.page.environment.toLowerCase()));\nconst envRefText = envRef ? `\\nENVIRONMENT: Match \"${envRef.name}\" reference exactly.` : '';\n\nconst prompt = `CONSISTENCY FIX - PAGE ${data.pageNumber}\n\nFIX REQUIRED: ${data.fixPrompt}\nISSUE: ${data.issue?.description || 'visual consistency'}\n\nCAPTION: \"${data.page?.caption || ''}\"\n\nCHARACTER CONSISTENCY (CRITICAL):\n${charRefs}\n- Match hair color, facial features, clothing from Page 1\n${envRefText}\n\nSTYLE: ${data.styleBible?.artStyle || data.aestheticStyle}\n- Match exact same style as other pages\n\nTECHNICAL: Full-page, no text, match existing pages exactly.\nSafe for ages 3-12.\n\nRegenerate page ${data.pageNumber} with fixes.`;\n\nreturn [{\n  json: {\n    ...data,\n    fixIllustrationPrompt: prompt\n  }\n}];"
      },
      "id": "317136bf-e5a0-4e55-a66f-f683c6805011",
      "name": "Build Fix Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7480,
        200
      ],
      "notes": "ADJUSTABLE: Edit fix instructions. Now includes environment reference matching."
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": {{ JSON.stringify($json.fixIllustrationPrompt) }}\n    }]\n  }],\n  \"generationConfig\": {\n    \"responseModalities\": [\"TEXT\", \"IMAGE\"]\n  }\n}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "255ca1db-64b4-4f58-86a0-cb7f8241a280",
      "name": "Regenerate Page",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        7700,
        200
      ],
      "credentials": {
        "httpQueryAuth": {
          "id": "",
          "name": "Gemini API Key"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "Uses gemini-3-pro-image-preview for consistency fixes."
    },
    {
      "parameters": {
        "unit": "seconds",
        "amount": 4
      },
      "id": "b776d835-da51-47da-aa6f-1e1fe3104598",
      "name": "Fix Rate Limit",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        7920,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "// Merge fixed pages back into the full page list - MEMORY OPTIMIZED\nconst fixedItems = $input.all();\nconst allData = fixedItems[0]?.json?.allData || $('Parse Consistency Review').first().json;\nconst saveToSupabase = allData.saveToSupabase || false;\n\nconst fixedPagesMap = new Map();\nfixedItems.forEach(item => {\n  if (item.json.pageNumber) {\n    const responseBody = item.json.body || item.json;\n    let imageData = null;\n    \n    try {\n      const candidates = responseBody?.candidates || [];\n      for (const candidate of candidates) {\n        const parts = candidate?.content?.parts || [];\n        for (const part of parts) {\n          if (part.inlineData) {\n            imageData = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;\n            break;\n          }\n        }\n        if (imageData) break;\n      }\n    } catch (e) {\n      console.error('Error extracting image:', e.message);\n    }\n    \n    if (imageData) {\n      // MEMORY OPTIMIZATION: Apply same logic as page aggregation\n      const finalImageData = saveToSupabase ? '[FIXED_AND_SAVED]' : imageData;\n      fixedPagesMap.set(item.json.pageNumber, finalImageData);\n    }\n  }\n});\n\nconst finalPages = (allData.generatedPages || []).map(page => {\n  if (fixedPagesMap.has(page.pageNumber)) {\n    return {\n      ...page,\n      imageData: fixedPagesMap.get(page.pageNumber),\n      wasFixed: true\n    };\n  }\n  return page;\n});\n\nreturn [{\n  json: {\n    storyId: allData.storyId,\n    targetAge: allData.targetAge,\n    intensity: allData.intensity,\n    aestheticStyle: allData.aestheticStyle,\n    saveToSupabase: allData.saveToSupabase,\n    analysis: allData.analysis,\n    styleBible: allData.styleBible,\n    characterReferences: allData.characterReferences,\n    environmentReferences: allData.environmentReferences,\n    storyArcSummary: allData.storyArcSummary,\n    heroImage: allData.heroImage,\n    generatedPages: finalPages,\n    fixedPageCount: fixedPagesMap.size,\n    consistencyReview: allData.consistencyReview\n  }\n}];"
      },
      "id": "eb70fce2-45ac-4ed0-b26c-578575b1c816",
      "name": "Merge Fixed Pages",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8140,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "// Final response assembly - MEMORY OPTIMIZED\nconst data = $input.first().json;\n\nconst response = {\n  success: true,\n  storyId: data.storyId,\n  title: data.analysis?.title || 'Untitled Story',\n  theme: data.analysis?.theme || '',\n  storyArcSummary: data.storyArcSummary || [],\n  \n  // For pages: if saved to Supabase, imageData will be placeholder\n  // Frontend should fetch from Supabase by storyId\n  pages: (data.generatedPages || []).map(page => ({\n    pageNumber: page.pageNumber,\n    caption: page.caption,\n    environment: page.environment,\n    imageData: page.imageData,\n    wasFixed: page.wasFixed || false,\n    savedToSupabase: page.hasSavedImage || page.imageData === '[SAVED_TO_SUPABASE]' || page.imageData === '[FIXED_AND_SAVED]'\n  })),\n  \n  characters: (data.characterReferences || []).map(char => ({\n    name: char.name,\n    role: char.role,\n    isHero: char.isHero || false,\n    description: char.description,\n    referenceImage: char.referenceImage,\n    savedToSupabase: char.hasSavedImage || char.referenceImage === '[SAVED_TO_SUPABASE]'\n  })),\n  \n  environments: (data.environmentReferences || []).map(env => ({\n    name: env.name,\n    referenceImage: env.referenceImage,\n    savedToSupabase: env.hasSavedImage || env.referenceImage === '[SAVED_TO_SUPABASE]'\n  })),\n  \n  styleBible: data.styleBible,\n  \n  metadata: {\n    pageCount: data.generatedPages?.length || 0,\n    characterCount: data.characterReferences?.length || 0,\n    environmentCount: data.environmentReferences?.length || 0,\n    consistencyIssuesFound: data.consistencyReview?.issues?.length || 0,\n    pagesFixed: data.fixedPageCount || 0,\n    targetAge: data.targetAge,\n    intensity: data.intensity,\n    aestheticStyle: data.aestheticStyle,\n    heroImageUsed: !!data.heroImage,\n    savedToSupabase: data.saveToSupabase || false\n  }\n};\n\nreturn [{ json: response }];"
      },
      "id": "66df01fb-3bb1-4e76-a8c6-b6ce13cf9bbb",
      "name": "12. Build Final Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8360,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Mark story as completed in Supabase\nconst data = $input.first().json;\nconst storyId = data.storyId;\n\n// Update story status to completed\nconst supabaseServiceKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpudnFxbnJ3dXpqdGRncWxrZ3ZmIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2NDAyNTgyMSwiZXhwIjoyMDc5NjAxODIxfQ.IWZV4x0vHZxBZAhOFKkwbB9LgZf8vk9e15MxBHhYxYU';\n\ntry {\n  await fetch(`https://znvqqnrwuzjtdgqlkgvf.supabase.co/rest/v1/stories?id=eq.${storyId}`, {\n    method: 'PATCH',\n    headers: {\n      'apikey': supabaseServiceKey,\n      'Authorization': `Bearer ${supabaseServiceKey}`,\n      'Content-Type': 'application/json',\n      'Prefer': 'return=minimal'\n    },\n    body: JSON.stringify({\n      status: 'completed',\n      current_step: 'done'\n    })\n  });\n  console.log('Story marked as completed:', storyId);\n} catch (e) {\n  console.error('Failed to mark story complete:', e.message);\n}\n\n// Return original data\nreturn [{ json: data }];"
      },
      "id": "mark-story-complete",
      "name": "Mark Story Complete",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8470,
        300
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "8603ce64-aa94-411a-ad11-7ac1622073cf",
      "name": "13. Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        8580,
        300
      ]
    }
  ],
  "connections": {
    "1. Webhook Input": {
      "main": [
        [
          {
            "node": "Extract & Validate Inputs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract & Validate Inputs": {
      "main": [
        [
          {
            "node": "Create Story Record",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Story Record": {
      "main": [
        [
          {
            "node": "2. Story Analyzer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "2. Story Analyzer": {
      "main": [
        [
          {
            "node": "Parse Story Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Story Analysis": {
      "main": [
        [
          {
            "node": "3. Scene Selector",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "3. Scene Selector": {
      "main": [
        [
          {
            "node": "Parse Scenes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Scenes": {
      "main": [
        [
          {
            "node": "4. Caption Writer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "4. Caption Writer": {
      "main": [
        [
          {
            "node": "Parse Captions & Build Pages",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Captions & Build Pages": {
      "main": [
        [
          {
            "node": "5. Character Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "5. Character Extractor": {
      "main": [
        [
          {
            "node": "6. Parse Characters & Create Style Bible",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "6. Parse Characters & Create Style Bible": {
      "main": [
        [
          {
            "node": "Save to Supabase?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save to Supabase?": {
      "main": [
        [
          {
            "node": "7. Save to Supabase",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Continue Pipeline",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "7. Save to Supabase": {
      "main": [
        [
          {
            "node": "Continue Pipeline",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Continue Pipeline": {
      "main": [
        [
          {
            "node": "Prep Character Portraits",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prep Character Portraits": {
      "main": [
        [
          {
            "node": "8. Character Portrait Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "8. Character Portrait Loop": {
      "main": [
        [
          {
            "node": "Aggregate Character Portraits",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Portrait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Portrait": {
      "main": [
        [
          {
            "node": "Parse + Save + Strip Character",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse + Save + Strip Character": {
      "main": [
        [
          {
            "node": "Character Rate Limit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Character Rate Limit": {
      "main": [
        [
          {
            "node": "8. Character Portrait Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Character Portraits": {
      "main": [
        [
          {
            "node": "Prep Environment References",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prep Environment References": {
      "main": [
        [
          {
            "node": "8b. Environment Reference Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "8b. Environment Reference Loop": {
      "main": [
        [
          {
            "node": "Aggregate Environment References",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Environment Reference",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Environment Reference": {
      "main": [
        [
          {
            "node": "Parse + Save + Strip Environment",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse + Save + Strip Environment": {
      "main": [
        [
          {
            "node": "Environment Rate Limit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Environment Rate Limit": {
      "main": [
        [
          {
            "node": "8b. Environment Reference Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Environment References": {
      "main": [
        [
          {
            "node": "Prep Page Illustrations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prep Page Illustrations": {
      "main": [
        [
          {
            "node": "9. Page Illustrator Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "9. Page Illustrator Loop": {
      "main": [
        [
          {
            "node": "Aggregate Pages",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Page Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Page Prompt": {
      "main": [
        [
          {
            "node": "Generate Page Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Page Image": {
      "main": [
        [
          {
            "node": "Parse + Save + Strip Page",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse + Save + Strip Page": {
      "main": [
        [
          {
            "node": "Page Rate Limit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Page Rate Limit": {
      "main": [
        [
          {
            "node": "9. Page Illustrator Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Pages": {
      "main": [
        [
          {
            "node": "10. Consistency Reviewer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "10. Consistency Reviewer": {
      "main": [
        [
          {
            "node": "Parse Consistency Review",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Consistency Review": {
      "main": [
        [
          {
            "node": "Needs Fixing?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Fixing?": {
      "main": [
        [
          {
            "node": "Prep Fix Loop",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "12. Build Final Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prep Fix Loop": {
      "main": [
        [
          {
            "node": "11. Consistency Fixer Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "11. Consistency Fixer Loop": {
      "main": [
        [
          {
            "node": "Merge Fixed Pages",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Fix Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Fix Prompt": {
      "main": [
        [
          {
            "node": "Regenerate Page",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Regenerate Page": {
      "main": [
        [
          {
            "node": "Fix Rate Limit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fix Rate Limit": {
      "main": [
        [
          {
            "node": "11. Consistency Fixer Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Fixed Pages": {
      "main": [
        [
          {
            "node": "12. Build Final Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "12. Build Final Response": {
      "main": [
        [
          {
            "node": "Mark Story Complete",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Story Complete": {
      "main": [
        [
          {
            "node": "13. Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-11-29T00:00:00.000Z",
  "versionId": "5"
}